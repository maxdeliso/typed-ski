/**
 * Code generation utilities for arena header constants
 *
 * This module provides functions to generate and validate TypeScript constants
 * from Rust struct definitions, ensuring type safety across the Rust/TypeScript boundary.
 *
 * @module
 */

import { type ParsedStruct, parseRustStruct } from "../parser/rustStruct.ts";

/**
 * Generate TypeScript constants for Ring<T> struct header layout
 *
 * The Ring struct has a specific layout with cache-line alignment:
 * - head: AtomicU32 at offset 0
 * - not_full: AtomicU32 at offset 4
 * - _pad1: [u8; 56] padding to 64-byte boundary
 * - tail: AtomicU32 at offset 64 (16 u32 words)
 * - not_empty: AtomicU32 at offset 68 (17 u32 words)
 * - _pad2: [u8; 56] padding to next 64-byte boundary
 * - mask: u32 at offset 128 (32 u32 words)
 * - entries: u32 at offset 132 (33 u32 words)
 *
 * Total header size: 192 bytes (48 u32 words)
 *
 * @returns TypeScript code for Ring header constants
 */
export function generateRingHeaderConstants(): string {
  return `/**
 * Ring buffer header constants
 *
 * This file is automatically generated by scripts/generate-arena-header.ts
 * from rust/src/arena.rs. Do not edit it manually.
 *
 * These constants match the memory layout of the Ring<T> struct defined in
 * rust/src/arena.rs (lines 424-481). The struct uses #[repr(C, align(64))]
 * for cache-line alignment.
 *
 * Memory layout (when viewed as Uint32Array):
 * - Offset 0-15:   First cache line (head, not_full, padding)
 * - Offset 16-31:  Second cache line (tail, not_empty, padding)
 * - Offset 32-33:  mask and entries fields
 * - Offset 48+:    Slots array begins
 *
 * Total header size: 192 bytes (48 u32 words)
 *
 * @see rust/src/arena.rs:450-481 for the Rust struct definition
 */
export const RING_HEADER_BYTES = 192;
export const RING_HEADER_U32 = RING_HEADER_BYTES / 4;
export const RING_HEAD_INDEX = 0;
export const RING_NOT_FULL_INDEX = 1;
export const RING_TAIL_INDEX = 16;
export const RING_NOT_EMPTY_INDEX = 17;
export const RING_MASK_INDEX = 32;
export const RING_ENTRIES_INDEX = 33;
`;
}

/**
 * Generate TypeScript enum constants from a Rust struct's field names
 *
 * @param structName - Name of the struct (e.g., "SabHeader")
 * @param fields - Array of field names from the parsed struct
 * @returns TypeScript code for the enum and related constants
 */
export function generateArenaHeaderConstants(
  structName: string,
  fields: string[],
): string {
  // Generate TypeScript constants
  const constants = fields.map((field, index) => {
    // Convert snake_case to SCREAMING_SNAKE_CASE
    // Handle both snake_case and camelCase
    const constName = field
      .replace(/([a-z])([A-Z])/g, "$1_$2") // camelCase -> camel_Case
      .toUpperCase(); // Convert to uppercase
    return `  /** Index of ${field} field in ${structName} (u32 array view) */\n  ${constName} = ${index},`;
  }).join("\n");

  const enumName = `${structName}Field`;

  return `/**
 * ${structName} field indices
 *
 * This file is automatically generated by scripts/generate-arena-header.ts
 * from rust/src/arena.rs. Do not edit it manually.
 *
 * These constants represent the byte offsets (divided by 4) into the ${structName}
 * struct when viewed as a Uint32Array. They match the field order in the Rust
 * #[repr(C)] struct definition.
 *
 * @module
 */

/**
 * Field indices for ${structName} struct (as Uint32Array indices)
 *
 * The header is laid out as a Uint32Array starting at baseAddr.
 * Each field index corresponds to its position in the struct.
 */
export enum ${enumName} {
${constants}
}

/**
 * Number of u32 words in the ${structName} struct
 */
export const ${structName.toUpperCase()}_HEADER_SIZE_U32 = ${fields.length};

/**
 * Field names in order (for debugging/validation)
 */
export const ${structName.toUpperCase()}_HEADER_FIELDS = [
${fields.map((f) => `  "${f}"`).join(",\n")}
] as const;
`;
}

/**
 * Parse a Rust struct from source code and generate TypeScript constants
 *
 * @param rustSource - The Rust source code containing the struct definition
 * @param structName - The name of the struct to parse (e.g., "SabHeader")
 * @returns The generated TypeScript code
 */
export function generateFromRustSource(
  rustSource: string,
  structName: string,
): string {
  const parsedStruct = parseRustStruct(rustSource, structName);
  const fields = parsedStruct.fields.map((f) => f.name);

  if (fields.length === 0) {
    throw new Error(`Could not parse any fields from ${structName} struct`);
  }

  return generateArenaHeaderConstants(structName, fields);
}

/**
 * Validation result for arena header constants
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  fieldCount: number;
}

/**
 * Check if a Rust type is u32-sized (safe for Uint32Array access)
 * Valid types: u32, AtomicU32, and other 4-byte types
 */
function isU32SizedType(type: string): boolean {
  const normalized = type.trim();
  // Allow u32 and AtomicU32 (both are 4 bytes)
  // Also allow types that end with u32 (like MyU32, etc.) but be conservative
  return normalized === "u32" || normalized === "AtomicU32" ||
    normalized.startsWith("AtomicU32");
}

/**
 * Validate that generated TypeScript constants match the Rust struct
 *
 * @param rustSource - The Rust source code
 * @param generatedSource - The generated TypeScript source code
 * @param structName - The name of the struct (e.g., "SabHeader")
 * @returns Validation result with any errors found
 */
export function validateArenaHeader(
  rustSource: string,
  generatedSource: string,
  structName: string,
): ValidationResult {
  const errors: string[] = [];

  // Parse Rust struct
  let parsedStruct: ParsedStruct;
  try {
    parsedStruct = parseRustStruct(rustSource, structName);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    errors.push(`Error parsing ${structName} struct: ${message}`);
    return { valid: false, errors, fieldCount: 0 };
  }

  // Validate struct has #[repr(C)] for predictable layout
  if (!parsedStruct.hasReprC) {
    errors.push(
      `Struct ${structName} must have #[repr(C)] or #[repr(C, align(...))] attribute for predictable memory layout`,
    );
  }

  // Validate all fields are u32-sized (critical for Uint32Array access)
  const invalidTypes: string[] = [];
  for (const field of parsedStruct.fields) {
    if (!isU32SizedType(field.type)) {
      invalidTypes.push(
        `Field '${field.name}' has type '${field.type}' which is not u32-sized (must be u32 or AtomicU32)`,
      );
    }
  }
  if (invalidTypes.length > 0) {
    errors.push(
      `Type validation failed:\n${
        invalidTypes.map((e) => `  - ${e}`).join("\n")
      }`,
    );
  }

  const rustFields = parsedStruct.fields.map((f) => f.name);
  const fieldsArrayName = `${structName.toUpperCase()}_HEADER_FIELDS`;
  const fieldsMatch = generatedSource.match(
    new RegExp(
      `export\\s+const\\s+${fieldsArrayName}\\s*=\\s*\\[([^\\]]+)\\]`,
      "s",
    ),
  );

  if (!fieldsMatch) {
    errors.push(`Could not find ${fieldsArrayName} in generated file`);
    return { valid: false, errors, fieldCount: rustFields.length };
  }

  const generatedFields = fieldsMatch[1]
    .split(",")
    .map((f) => f.trim().replace(/^["']|["']$/g, ""))
    .filter((f) => f.length > 0);

  if (rustFields.length !== generatedFields.length) {
    errors.push(
      `Field count mismatch: Rust has ${rustFields.length}, generated has ${generatedFields.length}`,
    );
  }

  const minLen = Math.min(rustFields.length, generatedFields.length);
  for (let i = 0; i < minLen; i++) {
    if (rustFields[i] !== generatedFields[i]) {
      errors.push(
        `Field mismatch at index ${i}: Rust="${rustFields[i]}", Generated="${
          generatedFields[i]
        }"`,
      );
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    fieldCount: rustFields.length,
  };
}
