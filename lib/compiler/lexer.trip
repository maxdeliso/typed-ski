module Lexer

import Prelude Bool
import Prelude List
import Prelude nil
import Prelude cons
import Prelude matchList
import Prelude tail
import Prelude if
import Prelude and
import Prelude or
import Prelude true
import Prelude false
import Prelude Result
import Prelude Err
import Prelude Ok
import Prelude ParseError
import Prelude MkParseError
import Prelude Maybe
import Prelude Some
import Prelude None
import Prelude Pair
import Prelude MkPair
import Prelude fst
import Prelude snd
import Prelude foldl
import Prelude append
import Prelude Bin
import Prelude addBin
import Prelude mulBin
import Prelude subBin
import Prelude eqBin
import Prelude lteBin
import Nat Nat
import Nat toBin

export Token
export T_LParen
export T_RParen
export T_LBrace
export T_RBrace
export T_LBracket
export T_RBracket
export T_Backslash
export T_Arrow
export T_FatArrow
export T_Eq
export T_Colon
export T_Hash
export T_Pipe
export T_Dot
export T_Comma
export T_Keyword
export T_Ident
export T_Nat
export T_EOF
export tokenize
export tokenizeBin
export tokenizeAcc
export kwPoly
export isKeywordPoly
export eqListFast
export binFromDigitList
export mapResult
export anyEqBin
export isSpaceBin
export isDigitBin
export isAlphaBin
export isIdentCharBin
export bin_space
export bin_newline
export bin_cr
export bin_tab
export bin_underscore
export bin_3e
export bin_dash
export bin_eq
export reverse
export simpleTokensBin
export lookupTokenBin
export bin_0
export bin_9
export bin_a
export bin_z
export bin_A
export bin_Z
export isDigitBin
export isLowerBin
export isUpperBin
export isAlphaBin
export isIdentCharBin
export consumeIdent
export consumeDigits

data Token =
  | T_LParen
  | T_RParen
  | T_LBrace
  | T_RBrace
  | T_LBracket
  | T_RBracket
  | T_Backslash
  | T_Arrow
  | T_FatArrow
  | T_Eq
  | T_Colon
  | T_Hash
  | T_Pipe
  | T_Dot
  | T_Comma
  | T_Keyword (List Bin)
  | T_Ident (List Bin)
  | T_Nat Bin
  | T_EOF

poly bin_space = 32
poly bin_newline = 10
poly bin_cr = 13
poly bin_tab = 9
poly bin_underscore = 95
poly bin_3e = 62
poly bin_dash = 45
poly bin_eq = 61

poly isSpaceBin = \c : Bin =>
  if [Bool] (eqBin c bin_space) (\u : Bin => true)
  (\u : Bin => if [Bool] (eqBin c bin_newline) (\u : Bin => true)
  (\u : Bin => if [Bool] (eqBin c bin_cr) (\u : Bin => true)
  (\u : Bin => eqBin c bin_tab)))

poly rec anyEqBin = \c : Bin => \xs : List Bin =>
  matchList [Bin] [Bool] xs false
    (\h : Bin => \t : List Bin =>
      if [Bool] (eqBin c h) (\u : Bin => true) (\u : Bin => anyEqBin c t))

poly bin_0 = 48
poly bin_9 = 57
poly bin_a = 97
poly bin_z = 122
poly bin_A = 65
poly bin_Z = 90

poly isDigitBin = \c : Bin =>
  and (lteBin bin_0 c) (lteBin c bin_9)

poly isLowerBin = \c : Bin =>
  and (lteBin bin_a c) (lteBin c bin_z)

poly isUpperBin = \c : Bin =>
  and (lteBin bin_A c) (lteBin c bin_Z)

poly isAlphaBin = \c : Bin =>
  if [Bool] (isLowerBin c) (\u : Bin => true) (\u : Bin => isUpperBin c)

poly isIdentCharBin = \c : Bin =>
  if [Bool] (isAlphaBin c) (\u : Bin => true)
  (\u : Bin => if [Bool] (isDigitBin c) (\u : Bin => true) (\u : Bin => eqBin c bin_underscore))


poly rec eqListFast = \a : List Bin => \b : List Bin =>
  matchList [Bin] [Bool] a
    (matchList [Bin] [Bool] b true (\hb : Bin => \tb : List Bin => false))
    (\ha : Bin => \ta : List Bin =>
      matchList [Bin] [Bool] b false
        (\hb : Bin => \tb : List Bin =>
          if [Bool] (eqBin ha hb)
            (\u : Bin => eqListFast ta tb)
            (\u : Bin => false)))

poly kwPoly = "poly"
poly isKeywordPoly = \word : List Bin => eqListFast word kwPoly

poly binFromDigitList = \digits : List Bin =>
  let ten = 10 in
  let zeroChar = bin_0 in
  foldl [Bin] [Bin]
    (\acc : Bin => \d : Bin =>
      let digit = subBin d zeroChar in
      addBin (mulBin acc ten) digit)
    0
    digits

poly mapResult = #A => #B => \f : A -> B => \res : Result ParseError A =>
  match res [Result ParseError B] {
    | Err e => Err [ParseError] [B] e
    | Ok val => Ok [ParseError] [B] (f val)
  }

poly simpleTokensBin =
  cons [Pair Bin Token] (MkPair [Bin] [Token] 40 T_LParen)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 41 T_RParen)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 123 T_LBrace)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 125 T_RBrace)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 91 T_LBracket)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 93 T_RBracket)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 92 T_Backslash)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 58 T_Colon)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 35 T_Hash)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 124 T_Pipe)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 46 T_Dot)
  (cons [Pair Bin Token] (MkPair [Bin] [Token] 44 T_Comma)
  (nil [Pair Bin Token]))))))))))))

poly rec lookupTokenBin = \c : Bin => \list : List (Pair Bin Token) =>
  matchList [Pair Bin Token] [Maybe Token] list
    (None [Token])
    (\h : Pair Bin Token => \t : List (Pair Bin Token) =>
       if [Maybe Token]
         (eqBin c (fst [Bin] [Token] h))
         (\u : Bin => Some [Token] (snd [Bin] [Token] h))
         (\u : Bin => lookupTokenBin c t)
    )

poly reverse = #A => \xs : List A =>
  foldl [A] [List A]
    (\acc : List A => \x : A => cons [A] x acc)
    (nil [A])
    xs

poly rec consumeIdent = \acc : List Bin => \input : List Bin =>
  matchList [Bin] [Pair (List Bin) (List Bin)] input
    (MkPair [List Bin] [List Bin] (reverse [Bin] acc) (nil [Bin]))
    (\h : Bin => \t : List Bin =>
       if [Pair (List Bin) (List Bin)] (isIdentCharBin h)
         (\u : Bin => consumeIdent (cons [Bin] h acc) t)
         (\u : Bin => MkPair [List Bin] [List Bin] (reverse [Bin] acc) input)
    )

poly rec consumeDigits = \acc : List Bin => \input : List Bin =>
  matchList [Bin] [Pair (List Bin) (List Bin)] input
    (MkPair [List Bin] [List Bin] (reverse [Bin] acc) (nil [Bin]))
    (\h : Bin => \t : List Bin =>
       if [Pair (List Bin) (List Bin)] (isDigitBin h)
         (\u : Bin => consumeDigits (cons [Bin] h acc) t)
         (\u : Bin => MkPair [List Bin] [List Bin] (reverse [Bin] acc) input)
    )

poly rec tokenizeAcc = \input : List Bin => \accRev : List Token =>
  matchList [Bin] [Result ParseError (List Token)] input
    (Ok [ParseError] [List Token] accRev)
    (\c : Bin => \cs : List Bin =>
      if [Result ParseError (List Token)] (isSpaceBin c)
        (\u : Bin => tokenizeAcc cs accRev)
        (\u : Bin =>

      if [Result ParseError (List Token)]
        (and (eqBin c bin_dash) (matchList [Bin] [Bool] cs false (\h : Bin => \t : List Bin => eqBin bin_3e h)))
        (\u : Bin =>
          let rest = tail [Bin] cs in
          tokenizeAcc rest (cons [Token] T_Arrow accRev))
        (\u : Bin =>

      if [Result ParseError (List Token)]
        (and (eqBin c bin_eq) (matchList [Bin] [Bool] cs false (\h : Bin => \t : List Bin => eqBin bin_3e h)))
        (\u : Bin =>
          let rest = tail [Bin] cs in
          tokenizeAcc rest (cons [Token] T_FatArrow accRev))
        (\u : Bin =>

      match (lookupTokenBin c simpleTokensBin) [Result ParseError (List Token)] {
        | Some tok =>
            tokenizeAcc cs (cons [Token] tok accRev)

        | None =>
            if [Result ParseError (List Token)] (isAlphaBin c)
              (\u : Bin =>
                match (consumeIdent (cons [Bin] c (nil [Bin])) cs) [Result ParseError (List Token)] {
                  | MkPair taken remaining =>
                      let tok =
                        if [Token] (isKeywordPoly taken)
                          (\u : Bin => T_Keyword taken)
                          (\u : Bin => T_Ident taken)
                      in
                      tokenizeAcc remaining (cons [Token] tok accRev)
                })

              (\u : Bin =>
                if [Result ParseError (List Token)] (isDigitBin c)
                  (\u : Bin =>
                    match (consumeDigits (cons [Bin] c (nil [Bin])) cs) [Result ParseError (List Token)] {
                      | MkPair taken remaining =>
                          let n = binFromDigitList taken in
                          tokenizeAcc remaining (cons [Token] (T_Nat n) accRev)
                    })

                  (\u : Bin =>
                    if [Result ParseError (List Token)] (eqBin c bin_eq)
                      (\u : Bin => tokenizeAcc cs (cons [Token] T_Eq accRev))
                      (\u : Bin => Err [ParseError] [List Token] (MkParseError 0 (nil [Bin])))
                  ))
      }

      ))))

poly rec mapToBin = \xs : List Nat =>
  matchList [Nat] [List Bin] xs
    (nil [Bin])
    (\h : Nat => \t : List Nat => cons [Bin] (toBin h) (mapToBin t))

poly tokenizeBin = \input : List Bin =>
  match (tokenizeAcc input (nil [Token])) [Result ParseError (List Token)] {
    | Err e => Err [ParseError] [List Token] e
    | Ok rev =>
        let toks = reverse [Token] rev in
        Ok [ParseError] [List Token]
          (append [Token] toks (cons [Token] T_EOF (nil [Token])))
  }

poly tokenize = \input : List Nat =>
  tokenizeBin (mapToBin input)
