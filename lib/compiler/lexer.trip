module Lexer

import Prelude Nat
import Prelude Bool
import Prelude List
import Prelude nil
import Prelude cons
import Prelude matchList
import Prelude head
import Prelude tail
import Prelude dropWhile
import Prelude span
import Prelude if
import Prelude eq
import Prelude isZero
import Prelude and
import Prelude or
import Prelude zero
import Prelude succ
import Prelude add
import Prelude mul
import Prelude sub
import Prelude pred
import Prelude gte
import Prelude lte
import Prelude true
import Prelude false
import Prelude Result
import Prelude Err
import Prelude Ok
import Prelude ParseError
import Prelude MkParseError
import Prelude Maybe
import Prelude Some
import Prelude None
import Prelude Pair
import Prelude MkPair
import Prelude pair
import Prelude fst
import Prelude snd
import Prelude error
import Prelude foldl
import Prelude append

export Token
export T_LParen
export T_RParen
export T_LBrace
export T_RBrace
export T_LBracket
export T_RBracket
export T_Backslash
export T_Arrow
export T_FatArrow
export T_Eq
export T_Colon
export T_Hash
export T_Pipe
export T_Dot
export T_Comma
export T_Keyword
export T_Ident
export T_Nat
export T_EOF
export simpleTokens
export lookupToken
export tokenize
export isSpace
export isAlpha
export isDigit
export isIdentChar
export eqList
export kwPoly
export isKeywordPoly
export fromSNat
export sAdd
export sMul
export sSub
export snatFromDigitList
export natFromDigitList
export mapResult
export SNat
export SZ
export SS
export toSNat
export seq
export slte
export isSpaceSNat
export isDigitSNat
export isAlphaSNat
export isIdentCharSNat
export sn_space
export sn_newline
export sn_cr
export sn_tab
export sn_underscore

data Token =
  | T_LParen
  | T_RParen
  | T_LBrace
  | T_RBrace
  | T_LBracket
  | T_RBracket
  | T_Backslash
  | T_Arrow
  | T_FatArrow
  | T_Eq
  | T_Colon
  | T_Hash
  | T_Pipe
  | T_Dot
  | T_Comma
  | T_Keyword (List Nat)
  | T_Ident (List Nat)
  | T_Nat Nat
  | T_EOF

data SNat =
  | SZ
  | SS SNat

poly toSNat = \n : Nat => n [SNat] (\x : SNat => SS x) SZ

poly rec fromSNat = \n : SNat =>
  match n [Nat] {
    | SZ => zero
    | SS p => succ (fromSNat p)
  }

poly rec sAdd = \a : SNat => \b : SNat =>
  match a [SNat] {
    | SZ => b
    | SS pa => SS (sAdd pa b)
  }

poly rec sMul = \a : SNat => \b : SNat =>
  match b [SNat] {
    | SZ => SZ
    | SS pb => sAdd a (sMul a pb)
  }

poly rec sSub = \a : SNat => \b : SNat =>
  match b [SNat] {
    | SZ => a
    | SS pb =>
        match a [SNat] {
          | SZ => SZ
          | SS pa => sSub pa pb
        }
  }

poly rec seq = \a : SNat => \b : SNat =>
  match a [Bool] {
    | SZ => match b [Bool] {
        | SZ => true
        | SS _ => false
      }
    | SS pa => match b [Bool] {
        | SZ => false
        | SS pb => seq pa pb
      }
  }

poly rec slte = \a : SNat => \b : SNat =>
  match a [Bool] {
    | SZ => true
    | SS pa => match b [Bool] {
        | SZ => false
        | SS pb => slte pa pb
      }
  }
poly sn_space = toSNat ' '
poly sn_newline = toSNat '\n'
poly sn_cr = toSNat 13
poly sn_tab = toSNat 9
poly sn_underscore = toSNat 95

poly isSpaceSNat = \c : SNat =>
  if [Bool] (seq c sn_space) (\u : Nat => true)
  (\u : Nat => if [Bool] (seq c sn_newline) (\u : Nat => true)
  (\u : Nat => if [Bool] (seq c sn_cr) (\u : Nat => true)
  (\u : Nat => seq c sn_tab)))
poly isSpace = \c : Nat => isSpaceSNat (toSNat c)

poly rec anyEqSNat = \c : SNat => \xs : List SNat =>
  matchList [SNat] [Bool] xs false
    (\h : SNat => \t : List SNat =>
      if [Bool] (seq c h) (\u : Nat => true) (\u : Nat => anyEqSNat c t))

poly rec anyEq = \c : Nat => \xs : List Nat =>
  matchList [Nat] [Bool] xs false
    (\h : Nat => \t : List Nat =>
      or (eq c h) (anyEq c t))

poly digits =
  cons [Nat] '0'
  (cons [Nat] '1'
  (cons [Nat] '2'
  (cons [Nat] '3'
  (cons [Nat] '4'
  (cons [Nat] '5'
  (cons [Nat] '6'
  (cons [Nat] '7'
  (cons [Nat] '8'
  (cons [Nat] '9'
  (nil [Nat]))))))))))

poly digitsSNat =
  cons [SNat] (toSNat '0')
  (cons [SNat] (toSNat '1')
  (cons [SNat] (toSNat '2')
  (cons [SNat] (toSNat '3')
  (cons [SNat] (toSNat '4')
  (cons [SNat] (toSNat '5')
  (cons [SNat] (toSNat '6')
  (cons [SNat] (toSNat '7')
  (cons [SNat] (toSNat '8')
  (cons [SNat] (toSNat '9')
  (nil [SNat]))))))))))

poly lowers =
  cons [Nat] 'a'
  (cons [Nat] 'b'
  (cons [Nat] 'c'
  (cons [Nat] 'd'
  (cons [Nat] 'e'
  (cons [Nat] 'f'
  (cons [Nat] 'g'
  (cons [Nat] 'h'
  (cons [Nat] 'i'
  (cons [Nat] 'j'
  (cons [Nat] 'k'
  (cons [Nat] 'l'
  (cons [Nat] 'm'
  (cons [Nat] 'n'
  (cons [Nat] 'o'
  (cons [Nat] 'p'
  (cons [Nat] 'q'
  (cons [Nat] 'r'
  (cons [Nat] 's'
  (cons [Nat] 't'
  (cons [Nat] 'u'
  (cons [Nat] 'v'
  (cons [Nat] 'w'
  (cons [Nat] 'x'
  (cons [Nat] 'y'
  (cons [Nat] 'z'
  (nil [Nat]))))))))))))))))))))))))))

poly lowersSNat =
  cons [SNat] (toSNat 'a')
  (cons [SNat] (toSNat 'b')
  (cons [SNat] (toSNat 'c')
  (cons [SNat] (toSNat 'd')
  (cons [SNat] (toSNat 'e')
  (cons [SNat] (toSNat 'f')
  (cons [SNat] (toSNat 'g')
  (cons [SNat] (toSNat 'h')
  (cons [SNat] (toSNat 'i')
  (cons [SNat] (toSNat 'j')
  (cons [SNat] (toSNat 'k')
  (cons [SNat] (toSNat 'l')
  (cons [SNat] (toSNat 'm')
  (cons [SNat] (toSNat 'n')
  (cons [SNat] (toSNat 'o')
  (cons [SNat] (toSNat 'p')
  (cons [SNat] (toSNat 'q')
  (cons [SNat] (toSNat 'r')
  (cons [SNat] (toSNat 's')
  (cons [SNat] (toSNat 't')
  (cons [SNat] (toSNat 'u')
  (cons [SNat] (toSNat 'v')
  (cons [SNat] (toSNat 'w')
  (cons [SNat] (toSNat 'x')
  (cons [SNat] (toSNat 'y')
  (cons [SNat] (toSNat 'z')
  (nil [SNat]))))))))))))))))))))))))))

poly uppers =
  cons [Nat] 'A'
  (cons [Nat] 'B'
  (cons [Nat] 'C'
  (cons [Nat] 'D'
  (cons [Nat] 'E'
  (cons [Nat] 'F'
  (cons [Nat] 'G'
  (cons [Nat] 'H'
  (cons [Nat] 'I'
  (cons [Nat] 'J'
  (cons [Nat] 'K'
  (cons [Nat] 'L'
  (cons [Nat] 'M'
  (cons [Nat] 'N'
  (cons [Nat] 'O'
  (cons [Nat] 'P'
  (cons [Nat] 'Q'
  (cons [Nat] 'R'
  (cons [Nat] 'S'
  (cons [Nat] 'T'
  (cons [Nat] 'U'
  (cons [Nat] 'V'
  (cons [Nat] 'W'
  (cons [Nat] 'X'
  (cons [Nat] 'Y'
  (cons [Nat] 'Z'
  (nil [Nat]))))))))))))))))))))))))))

poly uppersSNat =
  cons [SNat] (toSNat 'A')
  (cons [SNat] (toSNat 'B')
  (cons [SNat] (toSNat 'C')
  (cons [SNat] (toSNat 'D')
  (cons [SNat] (toSNat 'E')
  (cons [SNat] (toSNat 'F')
  (cons [SNat] (toSNat 'G')
  (cons [SNat] (toSNat 'H')
  (cons [SNat] (toSNat 'I')
  (cons [SNat] (toSNat 'J')
  (cons [SNat] (toSNat 'K')
  (cons [SNat] (toSNat 'L')
  (cons [SNat] (toSNat 'M')
  (cons [SNat] (toSNat 'N')
  (cons [SNat] (toSNat 'O')
  (cons [SNat] (toSNat 'P')
  (cons [SNat] (toSNat 'Q')
  (cons [SNat] (toSNat 'R')
  (cons [SNat] (toSNat 'S')
  (cons [SNat] (toSNat 'T')
  (cons [SNat] (toSNat 'U')
  (cons [SNat] (toSNat 'V')
  (cons [SNat] (toSNat 'W')
  (cons [SNat] (toSNat 'X')
  (cons [SNat] (toSNat 'Y')
  (cons [SNat] (toSNat 'Z')
  (nil [SNat]))))))))))))))))))))))))))

poly isDigitSNat = \c : SNat => anyEqSNat c digitsSNat
poly isAlphaSNat = \c : SNat =>
  if [Bool] (anyEqSNat c lowersSNat) (\u : Nat => true) (\u : Nat => anyEqSNat c uppersSNat)
poly isIdentCharSNat = \c : SNat =>
  if [Bool] (isAlphaSNat c) (\u : Nat => true)
  (\u : Nat => if [Bool] (isDigitSNat c) (\u : Nat => true) (\u : Nat => seq c sn_underscore))

poly isDigit = \c : Nat => isDigitSNat (toSNat c)
poly isAlpha = \c : Nat => isAlphaSNat (toSNat c)
poly isIdentChar = \c : Nat => isIdentCharSNat (toSNat c)

poly rec eqList = \a : List Nat => \b : List Nat =>
  matchList [Nat] [Bool] a
    (matchList [Nat] [Bool] b true (\hb : Nat => \tb : List Nat => false))
    (\ha : Nat => \ta : List Nat =>
      matchList [Nat] [Bool] b false
        (\hb : Nat => \tb : List Nat =>
          and (eq ha hb) (eqList ta tb)))

poly kwPoly = "poly"

poly isKeywordPoly = \word : List Nat => eqList word kwPoly

poly snatFromDigitList = \digits : List Nat =>
  let ten = toSNat 10 in
  let zeroChar = toSNat '0' in
  foldl [Nat] [SNat]
    (\acc : SNat => \d : Nat =>
      let digit = sSub (toSNat d) zeroChar in
      sAdd (sMul acc ten) digit)
    SZ
    digits

poly natFromDigitList = \digits : List Nat =>
  fromSNat (snatFromDigitList digits)

poly mapResult = #A => #B => \f : A -> B => \res : Result ParseError A =>
  match res [Result ParseError B] {
    | Err e => Err [ParseError] [B] e
    | Ok val => Ok [ParseError] [B] (f val)
  }

poly simpleTokens =
  cons [Pair Nat Token] (MkPair [Nat] [Token] '(' T_LParen)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] ')' T_RParen)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] '{' T_LBrace)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] '}' T_RBrace)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] '[' T_LBracket)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] ']' T_RBracket)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] '\\' T_Backslash)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] ':' T_Colon)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] '#' T_Hash)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] '|' T_Pipe)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] '.' T_Dot)
  (cons [Pair Nat Token] (MkPair [Nat] [Token] ',' T_Comma)
  (nil [Pair Nat Token]))))))))))))

poly rec lookupToken = \c : Nat => \list : List (Pair Nat Token) =>
  matchList [Pair Nat Token] [Maybe Token] list
    None
    (\h : Pair Nat Token => \t : List (Pair Nat Token) =>
      if [Maybe Token] (eq c (fst [Nat] [Token] h))
        (\u : Nat => Some [Token] (snd [Nat] [Token] h))
        (\u : Nat => lookupToken c t))

poly reverse = #A => \xs : List A =>
  foldl [A] [List A]
    (\acc : List A => \x : A => cons [A] x acc)
    (nil [A])
    xs

poly snatEqChar = \c_snat : SNat => \char_nat : Nat =>
  seq c_snat (toSNat char_nat)

poly rec tokenizeAcc = \input : List Nat => \accRev : List Token =>
  let clean = dropWhile [Nat] isSpace input in

  matchList [Nat] [Result ParseError (List Token)] clean
    (Ok [ParseError] [List Token] accRev)
    (\c_church : Nat => \cs : List Nat =>
      let c = toSNat c_church in

      if [Result ParseError (List Token)]
        (and (snatEqChar c '-') (matchList [Nat] [Bool] cs false (\h : Nat => \t : List Nat => eq h '>')))
        (\u : Nat =>
          let rest = tail [Nat] cs in
          tokenizeAcc rest (cons [Token] T_Arrow accRev))
        (\u : Nat =>

      if [Result ParseError (List Token)]
        (and (snatEqChar c '=') (matchList [Nat] [Bool] cs false (\h : Nat => \t : List Nat => eq h '>')))
        (\u : Nat =>
          let rest = tail [Nat] cs in
          tokenizeAcc rest (cons [Token] T_FatArrow accRev))
        (\u : Nat =>

      match (lookupToken c_church simpleTokens) [Result ParseError (List Token)] {
        | Some tok =>
            tokenizeAcc cs (cons [Token] tok accRev)

        | None =>
            if [Result ParseError (List Token)] (isAlphaSNat c)
              (\u : Nat =>
                let split = span [Nat] isIdentChar clean in
                let taken = fst [List Nat] [List Nat] split in
                let remaining = snd [List Nat] [List Nat] split in
                let tok =
                  if [Token] (isKeywordPoly taken)
                    (\u : Nat => T_Keyword taken)
                    (\u : Nat => T_Ident taken)
                in
                tokenizeAcc remaining (cons [Token] tok accRev))

              (\u : Nat =>
                if [Result ParseError (List Token)] (isDigitSNat c)
                  (\u : Nat =>
                    let split = span [Nat] isDigit clean in
                    let taken = fst [List Nat] [List Nat] split in
                    let remaining = snd [List Nat] [List Nat] split in
                    let n = fromSNat (snatFromDigitList taken) in
                    tokenizeAcc remaining (cons [Token] (T_Nat n) accRev))

                  (\u : Nat =>
                    Err [ParseError] [List Token] (MkParseError zero (nil [Nat]))))
      }

      )))

poly tokenize = \input : List Nat =>
  match (tokenizeAcc input (nil [Token])) [Result ParseError (List Token)] {
    | Err e => Err [ParseError] [List Token] e
    | Ok rev =>
        let toks = reverse [Token] rev in
        Ok [ParseError] [List Token]
          (append [Token] toks (cons [Token] T_EOF (nil [Token])))
  }
