module Lexer

import Prelude Nat
import Prelude Bool
import Prelude List
import Prelude nil
import Prelude cons
import Prelude matchList
import Prelude head
import Prelude tail
import Prelude dropWhile
import Prelude if
import Prelude isZero
import Prelude and
import Prelude or
import Prelude zero
import Prelude succ
import Prelude add
import Prelude mul
import Prelude sub
import Prelude pred
import Prelude gte
import Prelude lte
import Prelude true
import Prelude false
import Prelude Result
import Prelude Err
import Prelude Ok
import Prelude ParseError
import Prelude MkParseError
import Prelude Maybe
import Prelude Some
import Prelude None
import Prelude Pair
import Prelude MkPair
import Prelude pair
import Prelude fst
import Prelude snd
import Prelude error
import Prelude foldl
import Prelude append

export Token
export T_LParen
export T_RParen
export T_LBrace
export T_RBrace
export T_LBracket
export T_RBracket
export T_Backslash
export T_Arrow
export T_FatArrow
export T_Eq
export T_Colon
export T_Hash
export T_Pipe
export T_Dot
export T_Comma
export T_Keyword
export T_Ident
export T_Nat
export T_EOF
export tokenize
export tokenizeAcc
export isSpace
export isAlpha
export isDigit
export isIdentChar
export kwPoly
export isKeywordPoly
export fromSNat
export sAdd
export sMul
export sSub
export snatFromDigitList
export natFromDigitList
export mapResult
export SNat
export SZ
export SS
export toSNat
export seq
export slte
export anyEqSNat
export snatEqChar
export isSpaceSNat
export isDigitSNat
export isAlphaSNat
export isIdentCharSNat
export sn_space
export sn_newline
export sn_cr
export sn_tab
export sn_underscore
export reverse
export simpleTokensSNat
export lookupTokenSNat
export eqListFast
export sn_0
export sn_9
export sn_a
export sn_z
export sn_A
export sn_Z
export isDigitSNat
export isLowerSNat
export isUpperSNat
export isAlphaSNat
export isIdentCharSNat
export isDigit
export isAlpha
export isIdentChar
export consumeIdent
export consumeDigits

data Token =
  | T_LParen
  | T_RParen
  | T_LBrace
  | T_RBrace
  | T_LBracket
  | T_RBracket
  | T_Backslash
  | T_Arrow
  | T_FatArrow
  | T_Eq
  | T_Colon
  | T_Hash
  | T_Pipe
  | T_Dot
  | T_Comma
  | T_Keyword (List Nat)
  | T_Ident (List Nat)
  | T_Nat Nat
  | T_EOF

data SNat =
  | SZ
  | SS SNat

poly toSNat = \n : Nat => n [SNat] (\x : SNat => SS x) SZ

poly rec fromSNat = \n : SNat =>
  match n [Nat] {
    | SZ => zero
    | SS p => succ (fromSNat p)
  }

poly rec sAdd = \a : SNat => \b : SNat =>
  match a [SNat] {
    | SZ => b
    | SS pa => SS (sAdd pa b)
  }

poly rec sMul = \a : SNat => \b : SNat =>
  match b [SNat] {
    | SZ => SZ
    | SS pb => sAdd a (sMul a pb)
  }

poly rec sSub = \a : SNat => \b : SNat =>
  match b [SNat] {
    | SZ => a
    | SS pb =>
        match a [SNat] {
          | SZ => SZ
          | SS pa => sSub pa pb
        }
  }

poly rec seq = \a : SNat => \b : SNat =>
  match a [Bool] {
    | SZ => match b [Bool] {
        | SZ => true
        | SS _ => false
      }
    | SS pa => match b [Bool] {
        | SZ => false
        | SS pb => seq pa pb
      }
  }

poly rec slte = \a : SNat => \b : SNat =>
  match a [Bool] {
    | SZ => true
    | SS pa => match b [Bool] {
        | SZ => false
        | SS pb => slte pa pb
      }
  }

poly sn_space = toSNat ' '
poly sn_newline = toSNat '\n'
poly sn_cr = toSNat 13
poly sn_tab = toSNat 9
poly sn_underscore = toSNat 95

poly isSpaceSNat = \c : SNat =>
  if [Bool] (seq c sn_space) (\u : Nat => true)
  (\u : Nat => if [Bool] (seq c sn_newline) (\u : Nat => true)
  (\u : Nat => if [Bool] (seq c sn_cr) (\u : Nat => true)
  (\u : Nat => seq c sn_tab)))
poly isSpace = \c : Nat => isSpaceSNat (toSNat c)

poly rec anyEqSNat = \c : SNat => \xs : List SNat =>
  matchList [SNat] [Bool] xs false
    (\h : SNat => \t : List SNat =>
      if [Bool] (seq c h) (\u : Nat => true) (\u : Nat => anyEqSNat c t))

poly sn_0 = toSNat '0'
poly sn_9 = toSNat '9'
poly sn_a = toSNat 'a'
poly sn_z = toSNat 'z'
poly sn_A = toSNat 'A'
poly sn_Z = toSNat 'Z'

poly isDigitSNat = \c : SNat =>
  and (slte sn_0 c) (slte c sn_9)

poly isLowerSNat = \c : SNat =>
  and (slte sn_a c) (slte c sn_z)

poly isUpperSNat = \c : SNat =>
  and (slte sn_A c) (slte c sn_Z)

poly isAlphaSNat = \c : SNat =>
  if [Bool] (isLowerSNat c) (\u : Nat => true) (\u : Nat => isUpperSNat c)

poly isIdentCharSNat = \c : SNat =>
  if [Bool] (isAlphaSNat c) (\u : Nat => true)
  (\u : Nat => if [Bool] (isDigitSNat c) (\u : Nat => true) (\u : Nat => seq c sn_underscore))

poly isDigit = \c : Nat => isDigitSNat (toSNat c)
poly isAlpha = \c : Nat => isAlphaSNat (toSNat c)
poly isIdentChar = \c : Nat => isIdentCharSNat (toSNat c)

poly rec eqListFast = \a : List Nat => \b : List Nat =>
  matchList [Nat] [Bool] a
    (matchList [Nat] [Bool] b true (\hb : Nat => \tb : List Nat => false))
    (\ha : Nat => \ta : List Nat =>
      matchList [Nat] [Bool] b false
        (\hb : Nat => \tb : List Nat =>
          if [Bool] (seq (toSNat ha) (toSNat hb))
            (\u : Nat => eqListFast ta tb)
            (\u : Nat => false)))

poly kwPoly = "poly"
poly isKeywordPoly = \word : List Nat => eqListFast word kwPoly

poly snatFromDigitList = \digits : List Nat =>
  let ten = toSNat 10 in
  let zeroChar = sn_0 in
  foldl [Nat] [SNat]
    (\acc : SNat => \d : Nat =>
      let digit = sSub (toSNat d) zeroChar in
      sAdd (sMul acc ten) digit)
    SZ
    digits

poly natFromDigitList = \digits : List Nat =>
  fromSNat (snatFromDigitList digits)

poly mapResult = #A => #B => \f : A -> B => \res : Result ParseError A =>
  match res [Result ParseError B] {
    | Err e => Err [ParseError] [B] e
    | Ok val => Ok [ParseError] [B] (f val)
  }

poly simpleTokensSNat =
  cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '(') T_LParen)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat ')') T_RParen)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '{') T_LBrace)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '}') T_RBrace)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '[') T_LBracket)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat ']') T_RBracket)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '\\') T_Backslash)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat ':') T_Colon)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '#') T_Hash)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '|') T_Pipe)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat '.') T_Dot)
  (cons [Pair SNat Token] (MkPair [SNat] [Token] (toSNat ',') T_Comma)
  (nil [Pair SNat Token]))))))))))))

poly rec lookupTokenSNat = \c : SNat => \list : List (Pair SNat Token) =>
  matchList [Pair SNat Token] [Maybe Token] list
    (None [Token])
    (\h : Pair SNat Token => \t : List (Pair SNat Token) =>
       if [Maybe Token]
         (seq c (fst [SNat] [Token] h))
         (\u : Nat => Some [Token] (snd [SNat] [Token] h))
         (\u : Nat => lookupTokenSNat c t)
    )

poly reverse = #A => \xs : List A =>
  foldl [A] [List A]
    (\acc : List A => \x : A => cons [A] x acc)
    (nil [A])
    xs

poly snatEqChar = \c_snat : SNat => \char_nat : Nat =>
  seq c_snat (toSNat char_nat)

poly rec consumeIdent = \acc : List Nat => \input : List Nat =>
  matchList [Nat] [Pair (List Nat) (List Nat)] input
    (MkPair [List Nat] [List Nat] (reverse [Nat] acc) (nil [Nat]))
    (\h : Nat => \t : List Nat =>
       if [Pair (List Nat) (List Nat)] (isIdentChar h)
         (\u : Nat => consumeIdent (cons [Nat] h acc) t)
         (\u : Nat => MkPair [List Nat] [List Nat] (reverse [Nat] acc) input)
    )

poly rec consumeDigits = \acc : List Nat => \input : List Nat =>
  matchList [Nat] [Pair (List Nat) (List Nat)] input
    (MkPair [List Nat] [List Nat] (reverse [Nat] acc) (nil [Nat]))
    (\h : Nat => \t : List Nat =>
       if [Pair (List Nat) (List Nat)] (isDigit h)
         (\u : Nat => consumeDigits (cons [Nat] h acc) t)
         (\u : Nat => MkPair [List Nat] [List Nat] (reverse [Nat] acc) input)
    )

poly rec tokenizeAcc = \input : List Nat => \accRev : List Token =>
  let clean = dropWhile [Nat] isSpace input in

  matchList [Nat] [Result ParseError (List Token)] clean
    (Ok [ParseError] [List Token] accRev)
    (\c_church : Nat => \cs : List Nat =>
      let c = toSNat c_church in

      if [Result ParseError (List Token)]
        (and (snatEqChar c '-') (matchList [Nat] [Bool] cs false (\h : Nat => \t : List Nat => snatEqChar (toSNat '>') h)))
        (\u : Nat =>
          let rest = tail [Nat] cs in
          tokenizeAcc rest (cons [Token] T_Arrow accRev))
        (\u : Nat =>

      if [Result ParseError (List Token)]
        (and (snatEqChar c '=') (matchList [Nat] [Bool] cs false (\h : Nat => \t : List Nat => snatEqChar (toSNat '>') h)))
        (\u : Nat =>
          let rest = tail [Nat] cs in
          tokenizeAcc rest (cons [Token] T_FatArrow accRev))
        (\u : Nat =>

      match (lookupTokenSNat c simpleTokensSNat) [Result ParseError (List Token)] {
        | Some tok =>
            tokenizeAcc cs (cons [Token] tok accRev)

        | None =>
            if [Result ParseError (List Token)] (isAlphaSNat c)
              (\u : Nat =>
                match (consumeIdent (nil [Nat]) clean) [Result ParseError (List Token)] {
                  | MkPair taken remaining =>
                      let tok =
                        if [Token] (isKeywordPoly taken)
                          (\u : Nat => T_Keyword taken)
                          (\u : Nat => T_Ident taken)
                      in
                      tokenizeAcc remaining (cons [Token] tok accRev)
                })

              (\u : Nat =>
                if [Result ParseError (List Token)] (isDigitSNat c)
                  (\u : Nat =>
                    match (consumeDigits (nil [Nat]) clean) [Result ParseError (List Token)] {
                      | MkPair taken remaining =>
                          let n = fromSNat (snatFromDigitList taken) in
                          tokenizeAcc remaining (cons [Token] (T_Nat n) accRev)
                    })

                  (\u : Nat =>
                    if [Result ParseError (List Token)] (snatEqChar c '=')
                      (\u : Nat => tokenizeAcc cs (cons [Token] T_Eq accRev))
                      (\u : Nat => Err [ParseError] [List Token] (MkParseError zero (nil [Nat])))
                  ))
      }

      )))

poly tokenize = \input : List Nat =>
  match (tokenizeAcc input (nil [Token])) [Result ParseError (List Token)] {
    | Err e => Err [ParseError] [List Token] e
    | Ok rev =>
        let toks = reverse [Token] rev in
        Ok [ParseError] [List Token]
          (append [Token] toks (cons [Token] T_EOF (nil [Token])))
  }
